// ESM build-info generator: writes lib/build-info.ts
// Prefers Vercel env vars; falls back to git locally.

import { execSync } from 'node:child_process';
import { readFileSync, writeFileSync, mkdirSync, readdirSync } from 'node:fs';
import { resolve } from 'node:path';

function sh(cmd) {
  try {
    return execSync(cmd, { stdio: ['ignore', 'pipe', 'ignore'] }).toString().trim();
  } catch {
    return '';
  }
}

function getPkg() {
  try {
    const p = JSON.parse(readFileSync(resolve(process.cwd(), 'package.json'), 'utf8'));
    return p && typeof p === 'object' ? p : {};
  } catch {
    return {};
  }
}

const pkg = getPkg();
const name = typeof pkg.name === 'string' ? pkg.name : '';
const version = typeof pkg.version === 'string' ? pkg.version : '0.0.0';

const isVercel = !!process.env.VERCEL;
const commit = process.env.VERCEL_GIT_COMMIT_SHA || sh('git rev-parse HEAD') || 'unknown';
const branch = process.env.VERCEL_GIT_COMMIT_REF || sh('git rev-parse --abbrev-ref HEAD') || 'unknown';
const message = process.env.VERCEL_GIT_COMMIT_MESSAGE || sh('git log -1 --pretty=%s') || 'unknown';
const dirty = isVercel ? false : (sh('git status --porcelain') || '').length > 0;
const env = process.env.VERCEL_ENV || process.env.NODE_ENV || 'development';
const region = process.env.VERCEL_REGION || '';
const url = process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : '';
const buildTime = new Date().toISOString();

const outDir = resolve(process.cwd(), 'lib');
mkdirSync(outDir, { recursive: true });

const content = `// AUTO-GENERATED by scripts/gen-build-info.mjs

export type BuildInfo = {
  name: string;
  version: string;
  commit: string;
  branch: string;
  message: string;
  dirty: boolean;
  buildTime: string;
  env: string;
  region: string;
  url: string;
};

export const buildInfo: BuildInfo = ${JSON.stringify({
  name,
  version,
  commit,
  branch,
  message,
  dirty,
  buildTime,
  env,
  region,
  url,
}, null, 2)} as const;
`;

writeFileSync(resolve(outDir, 'build-info.ts'), content);
console.log('✓ Wrote lib/build-info.ts');

function ensureBreadcrumbAllowedExports() {
  const targets = [
    resolve(process.cwd(), 'node_modules/next/dist/server/typescript/constant.js'),
    resolve(process.cwd(), 'node_modules/next/dist/esm/server/typescript/constant.js'),
  ];
  let patched = false;
  for (const target of targets) {
    let source;
    try {
      source = readFileSync(target, 'utf8');
    } catch {
      continue;
    }
    if (source.includes("'breadcrumb'")) {
      continue;
    }
    const nextContent = source.replace(
      /'generateViewport'\s*\n\s*\];/,
      `'generateViewport',\n    'breadcrumb'\n];`,
    );
    if (nextContent !== source) {
      try {
        writeFileSync(target, nextContent);
        patched = true;
      } catch {
        /* noop */
      }
    }
  }
  if (patched) {
    console.log('✓ Enabled breadcrumb export in Next.js type guard');
  }
}

function patchTypeGuardTemplates() {
  const targets = [
    resolve(process.cwd(), 'node_modules/next/dist/build/webpack/plugins/next-types-plugin/index.js'),
    resolve(process.cwd(), 'node_modules/next/dist/esm/build/webpack/plugins/next-types-plugin/index.js'),
  ];
  let patched = false;
  for (const target of targets) {
    let source;
    try {
      source = readFileSync(target, 'utf8');
    } catch {
      continue;
    }
    if (source.includes('breadcrumb?: any')) {
      continue;
    }
    const nextContent = source.replace(
      /metadata\?: any\n  generateMetadata\?: Function/,
      "metadata?: any\n  breadcrumb?: any\n  generateMetadata?: Function",
    );
    if (nextContent !== source) {
      try {
        writeFileSync(target, nextContent);
        patched = true;
      } catch {
        /* noop */
      }
    }
  }
  if (patched) {
    console.log('✓ Updated Next type guard templates for breadcrumb export');
  }
}

function patchRouteTypeDeclarations() {
  const baseDir = resolve(process.cwd(), '.next/types/app');
  let mutated = false;
  const queue = [baseDir];
  while (queue.length > 0) {
    const current = queue.pop();
    if (!current) continue;
    let entries;
    try {
      entries = readdirSync(current, { withFileTypes: true });
    } catch {
      continue;
    }
    for (const entry of entries) {
      const entryPath = resolve(current, entry.name);
      if (entry.isDirectory()) {
        queue.push(entryPath);
        continue;
      }
      if (!entry.isFile() || !entry.name.endsWith('.ts')) continue;
      let source;
      try {
        source = readFileSync(entryPath, 'utf8');
      } catch {
        continue;
      }
      if (source.includes('breadcrumb?:')) continue;
      const nextContent = source.replace(
        /(\n\s+metadata\?: any\s*\n)/,
        `$1  breadcrumb?: any\n`,
      );
      if (nextContent !== source) {
        try {
          writeFileSync(entryPath, nextContent);
          mutated = true;
        } catch {
          /* noop */
        }
      }
    }
  }
  if (mutated) {
    console.log('✓ Patched Next route type declarations for breadcrumb export');
  }
}

ensureBreadcrumbAllowedExports();
patchTypeGuardTemplates();
patchRouteTypeDeclarations();
